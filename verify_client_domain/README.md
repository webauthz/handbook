Verify Client Domain
====================

# Introduction

This is an extension to the Webauthz specification.

In Webauthz, a client application may register with an authorization server
using any origin. Later, when the client requests access to a resource,
the `grant_redirect_uri` value must match the client's origin.

However, there are situations in which a client needs to provide a
`grant_redirect_uri` that is within the same domain or a subdomain but does
not match the client's origin. Clients with a verified domain can use
any scheme, subdomain, or port in the `grant_redirect_uri`.

For example, a client would specify 'example.com' if it might later use
redirect URIs at 'subdomain1.example.com' and 'subdomain2.example.com'.

This extension adds this capability to
Webauthz as an optional feature.

# Overview

A new endpoint is added to the discovery document to inform clients that
domain verification is supported by the authorization server.

The domain verification process has the following steps:

* [Start](#start)
* [Ready](#ready)
* [Verify](#verify)
* [Status](#status)

When domain verification is successfully completed, the authorization server
updates the client's registration to indicate it has been verified using
this method. This verification might be a precondition for the client to
access other features of the authorization server that are not in the scope
of this specification. An authorization server MAY allow a client application
to verify multiple domains, but each domain verification must be processed
separately in accordance with this specification.

# Specification

## Discovery

The domain verification extension is declared in the discovery document
with `verify_client_domain_uri`. This informs clients about the location of
the domain verification API.

The discovery response should look like this:

```
HTTP/1.1 200 OK
Content-Type: application/json

{
  "webauthz_register_uri": "https://resource.example.com/webauthz/register",
  "webauthz_request_uri": "https://resource.example.com/webauthz/request",
  "webauthz_exchange_uri": "https://resource.example.com/webauthz/exchange",
  "verify_client_domain_uri": "https://resource.example.com/webauthz/verify-client-domain"
}
```

In addition to the keys specified by Webauthz (`webauthz_register_uri`,
`webauthz_request_uri`, and `webauthz_exchange_uri`),
the response object SHALL include values for the following keys:

* `verify_client_domain_uri` indicates where a client can request domain verification (see [Start](#start))

The values are determined by the authorization server administrator.

## Start

A client application starts the domain verification process by sending a request
to the `verify_client_domain_uri` specified in the discovery response.

The request MUST include the `Authorization` header with the `<client_token>`.

To make the request with `curl`:

```
curl \
  -H 'Accept: application/json' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer <client_token>' \
  -X POST \
  --data '{"domain": "<domain>"}' \
  '<verify_client_domain_uri>'
```

The `verify_client_domain_uri` was or obtained via the [discovery](#discovery) step.
The `client_id` is implicit because of the use of the client-specific `client_token`
in the `Authorization` header.
The `domain` parameter MUST be included and indicates the domain to be verified.

If the authorization header is missing or the client token is invalid,
the authorization server SHALL deny the request with
`401 Unauthorized`.

If the `domain` parameter is missing or is not a valid domain name, the
authorization server SHALL deny the request with `400 Bad Request`.

The authorization server MUST check that a client requesting domain verification
has already completed origin verification. If the client registration does not
indicate that the client origin is verified, the authorization server SHALL deny
the request with `403 Forbidden`.

The authorization server generates a new challenge comprised of a unique identifier
and a token.

A successful response should look like this:

```
HTTP/1.1 200 OK
Content-Type: application/json

{
  "challenge_id": "<challenge_id>",
  "challenge_token": "<challenge_token>",
  "challenge_max_seconds": <challenge_max_seconds>,
  "ready_uri": "<ready_uri>",
  "status_uri": "<status_uri>"
}
```

The response object SHALL include the following keys:

* `challenge_id` is a value generated by the authorization server to identify this
  domain verification challenge; the value MUST NOT include the characters `/`, `?`, `&`, `=`, `.`, or `#`
* `challenge_token` is a value generated by the authorization server
* `challenge_max_seconds` indicates the time available to complete the challenge
* `ready_uri` indicates the endpoint for notifying the authorization server that the
  client application is ready to complete the challenge
* `status_uri` indicates the endpoint for checking the challenge status

The client application should then configure a DNS TXT record to complete the
challenge. The record MUST be located at `<challenge_id>._webauthz-dns-challenge.<domain>`.

The content of the TXT record MUST be the `<challenge_token>`. The authorization server
SHALL trim any leading or trailing spaces from the response value.

To check the record with `dig`:

```
dig +short -t txt <challenge_id>._webauthz-dns-challenge.<domain>
```

The response should look like this:

```
"<challenge_token>"
```

After configuring the TXT record, the client application continues to the next step ([ready](#ready)).

## Ready

A client application continues the domain verification process by sending a request
to the `ready_uri` specified in the [start](#start) response.

The request MUST include the `Authorization` header with the `<client_token>`.

To make the request with `curl`:

```
curl \
  -H 'Accept: application/json' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer <client_token>' \
  -X POST \
  '<ready_uri>'
```

The `ready_uri` was or obtained via the [start](#start) step.
The `client_id` is implicit because of the use of the client-specific `client_token`
in the `Authorization` header.

If the authorization header is missing or the client token is invalid,
or the specified challenge was not found, or the challenge was created by
a different client,
the authorization server SHALL deny the request with
`401 Unauthorized`.

The authorization server MAY queue the challenge
to check later or check the challenge synchronously and return
an updated challenge status.

Where the authorization server queues the challenge to check later, the
authorization server SHALL respond with `202 Accepted`. The client SHOULD
check the status later using the `status_uri`.

Where the authorization server checks the challenge synchronously, the
authorization server response MUST be the same as the response for the `status_uri`.

## Verify

Verification is an authorization server task.

The authorization
server sends a DNS TXT request for `<challenge_id>._webauthz-dns-challenge.<domain>`.
When the authorization server receives a recofrd in response whose content is
`<challenge_token>`,
the authorization server updates the client registration to indicate the
domain is verified via DNS. If the response does not have the expected status or
body, the authorization server MUST NOT update the client registration.

## Status

A client application checks the status of its domain verification by sending
a request to the `status_uri` specified in the [start](#start) response.

The request MUST include the `Authorization` header with the `<client_token>`.

The status request is idempotent. The authorization server MUST NOT change the
status of a challenge in response to a status request. However, the authorization
server MAY impose rate limits and respond with `429 Too Many Requests` instead
of the status.

To make the request with `curl`:

```
curl \
  -H 'Accept: application/json' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer <client_token>' \
  -X GET \
  '<status_uri>'
```

The `status_uri` was or obtained via the [start](#start) step.
The `client_id` is implicit because of the use of the client-specific `client_token`
in the `Authorization` header.

If the authorization header is missing or the client token is invalid,
or the specified challenge was not found, or the challenge was created by
a different client,
the authorization server SHALL deny the request with
`401 Unauthorized`.

The authorization server checks the status of the challenge for the client.

The authorization server then responds to the client with the status of the
domain verification.

A successful status check response should look like this:

```
HTTP/1.1 200 OK
Content-Type: application/json

{
  "challenge_id": "<challenge_id>",
  "challenge_max_seconds": <challenge_max_seconds>,
  "status": "<status>"
}
```

The response object SHALL include the following keys:

* `challenge_id` is a value generated by the authorization server to identify this
  domain verification challenge
* `challenge_max_seconds` indicates the time available to complete the challenge
* `status` is one of the following values: 'pending', 'verified', or 'failed'

Meaning of the `status` values:

* 'pending' - the authorization server has scheduled the verification, or the verification
  is currently in progress, and the final status is not available yet; the client SHOULD
  retry the request later
* 'verified' - the authorization server has completed the verification and received
  the expected response; the client registration has been updated
* 'failed' - the authorization server could not complete the verification or received an
  unexpected response; the client SHOULD fix the problem and retry the request later

When the client application is done with the verification, the client SHOULD
remove the configured challenge so it is no longer available at the TXT record
for `<challenge_id>._webauthz-dns-challenge.<domain>`.

## Request

When a client application starts an access request with the authorization server,
the authorization server SHALL check
that the value is a URI whose authority matches the registered `client_domain` or a
subdomain of `client_domain` or whose origin matches the registered `client_origin`.

## Prompt

When the authorization server is showing the access request prompt to the
user, the authorization server MAY display the verified `client_domain` value instead
of the `client_origin` value in the prompt.

It might look like this:

```
Webauthz Resource Request

<client_name> (<client_domain>)
is requesting access to
<resource>.

<permissions>

<optional_parameters>

[Grant] [Deny]
```

# Configuration

To participate in the protocol, each of the parties must determine some
configuration settings that are shared with the other parties.

## Application

The application must have a way to configure a TXT record like
`<challenge_id>._webauthz-dns-challenge.<domain>` so it can
respond to challenges.

This can be automated if the client application has access to do this,
or it can be interactive by providing the hostname and the `challenge_token`
to the administrator so the administrator can create the resource.

## Authorization Server

To enable applications to request access to a resource, the authorization
server must define the following URIs:

* Verify Domain URI
* Ready URI
* Status URI

The Verify Domain URI is used by applications to start a client domain
verification request in the [start](#start) step.

The Ready URI and Status URI are provided to the client in the [start](#start)
response, so they can be different for each request (for example, they can
include the `challenge_id` in the path).

# Token usage

A token presented to the server must be sufficient to both
identify and authenticate the client.

# Token format

The format of the token is unspecified because it is opaque
to clients.

## Challenge token

Generated by the authorization server in response to an application's
verify client origin request.

# Discussion

## Challenge response

In contrast to the [ACME DNS-01](https://datatracker.ietf.org/doc/html/rfc8555#section-8.4) challenge protocol, a Webauthz client
application DOES NOT need to compute the response to the challenge. It merely
needs to use the value received from the authorization server.

The challenge token value generated by the authorization server MUST be bound to
the client that requested the verification.

## Scope of verification

The [ACME DNS-01](https://datatracker.ietf.org/doc/html/rfc8555#section-8.4) challenge protocol
is used to issue TLS certificates which are then trusted by other client applications when
making TLS connections to the domain. For this reason, domains must also publish a `CAA` record
type indicating the certificate authority that is allowed to issue certificates for that domain.

However, Webauthz client domain challenges are NOT used to issue TLS certificates. Webauthz
client domain challenges are used to verify that a client has control over the entire domain,
in order for an authorization server to allow that client to use any origin matching that
domain in its `grant_redirect_uri` values. The use of this verification is only between the
client application and the authorization server. For this reason, a separate record analogous
to the `CAA` record is not needed.

## Client application types

Domain verification is intended for web applications.
It is not intended for use by mobile or desktop applications. To ensure
it does not work for these client application types, client origin verification
is a pre-condition to domain verification.
